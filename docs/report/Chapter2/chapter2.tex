%\addcontentsline{toc}{chapter}{Development Process}
\chapter{Design \& Implementation}

The structure of this chapter follows the agile methodology used to develop the
Quiz Tool. Each section contains information about a sprint, allowing the reader
to gain more understanding of how the design and the tool itself evolved over time.

\section{Sprint 1 - Hello Quiz Tool}
\subsection{Sprint Planning}
The first sprint of the Quiz Tool focused on setting up the DevOps of the project,
and deployment of a "hello world" version of the tool consisting of the front end,
back end and nginx\cite{34} running together using docker-compose. It was also important
to investigate how to best structure the application to include both the front and the
back end of the application in a single GitHub repository. The following subsections
cover the most important aspects of the sprint, and the entire list of estimated
stories can be found in the \autoref{chap:spintstories} of this report.

\subsection{Application Structure}
The main goal of using docker-compose, was to have the whole application running in
the same manner locally on the developer's machine, during testing on Circle CI, and
in the production environment. This meant the application had to be containerised
using Docker, and containers had to be able to communicate with each other appropriately.
This was even more difficult considering Socket.io had to be incorporated, to allow
real time broadcast of lecture slides to students in the future. I have decided to
create a prototype of a very basic chat application, containerised using Docker and
orchestrated using docker-compose. The prototype had to be written in the MEAN stack,
and use Socket.io to prove it was possible to make all technologies work together.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.7\textwidth]{../../design/app_structure.jpg}
    \caption{The proof of concept application structure}
    \label{fig:appstrucure}
\end{figure}

\begin{figure}[h!]
  \begin{lstlisting}[basicstyle=\small]
  version: '2.0'
  services:
    client:
      build: client
      ports:
        - "80:80"
      links:
        - server_node
    server_node:
      build: server
      links:
        - database
    database:
      image: mongo
      ports:
        - "27017:27017"
  \end{lstlisting}
  \caption{The docker-compose.yml file describing the tool's structure}
\end{figure}

\newpage
\subsubsection{Front End Container}
The front end container consisted of Angular 4 and nginx reverse proxy. The structure
has been based on the \textit{Dockerized Angular 4 App (with Angular CLI)} repository\cite{35}.
The Socket.io client dependency has been added to allow sending messages to the back end
using sockets. The Dockerfile below uses the multi-stage build added in Docker 17.05. The
Angular app is compiled to JavaScript and HTML files during the initial stage of the build,
and then these files are copied to the nginx public folder to be served to clients.
This results in a lean, production ready image.

\begin{figure}[ht]
  \begin{lstlisting}[basicstyle=\tiny]
    ### STAGE 1: Build ###

    # We label our stage as 'builder'
    FROM node:8-alpine as builder

    COPY package.json package-lock.json ./

    RUN npm set progress=false && npm config set depth 0 && npm cache clean --force

    ## Storing node modules on a separate layer will prevent unnecessary npm installs at each build
    RUN npm i && mkdir /ng-app && cp -R ./node_modules ./ng-app

    WORKDIR /ng-app

    COPY . .

    ## Build the angular app in production mode and store the artifacts in dist folder
    RUN $(npm bin)/ng build --prod --build-optimizer

    ### STAGE 2: Setup ###

    FROM nginx:1.13.3-alpine

    ## Copy our default nginx config
    COPY nginx/default.conf /etc/nginx/conf.d/

    ## Remove default nginx website
    RUN rm -rf /usr/share/nginx/html/*

    ## From 'builder' stage copy over the artifacts in dist folder to default nginx public folder
    COPY --from=builder /ng-app/dist /usr/share/nginx/html

    CMD ["nginx", "-g", "daemon off;"]
  \end{lstlisting}
  \caption{Front End Dockerfile}
\end{figure}

\subsubsection{Back End Container}
The back end container consisted of a Node.js runtime, Express framework and the Socket.io
engine capable of pushing messages to clients using Sockets. The following Dockerfile illustrates
the very basic Node container.

\begin{figure}[ht]
    \begin{lstlisting}[basicstyle=\small]
    FROM node:carbon
    WORKDIR /usr/src/app
    COPY package*.json ./
    RUN npm install
    COPY . .
    EXPOSE 3000
    CMD [ "npm", "start" ]
  \end{lstlisting}
  \caption{Back End Dockerfile}
\end{figure}

\subsubsection{Database Container}
Finally, the MongoDB Docker image has been pulled automatically from the official mongo
Docker Hub registry\cite{36}.

\subsection{Continuous Integration}
Circle CI has been integrated with the GitHub repository containing the source code of the
Quiz Tool. Every time a pull request was made, Circle CI would be notified. It would then
assign a virtual machine build agent from a pool, and spin up a clean build environment.
It would then checkout the code and run the steps specified in the build config file, before
reporting if the build was successfull back to GitHub.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\textwidth]{circleci.jpg}
    \caption{Continuous Integration and Deployment}
    \label{fig:ci}
\end{figure}

\begin{figure}[h!]
  \begin{lstlisting}[basicstyle=\tiny, breaklines=true]
  version: 2
  jobs:
    build:
      machine: true

      working_directory: ~/repo

      steps:
        - checkout

        - run:
            name: install docker-compose
            command: |
              set -x
              sudo chown -R $(whoami) /usr/local/bin
              curl -L https://github.com/docker/compose/releases/download/1.11.2/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose
              chmod +x /usr/local/bin/docker-compose

        - run:
            name: docker compose build image
            command: |
              set -x
              docker-compose build
              docker-compose up

        - run:
            name: unit tests
            command: |
              curl localhost

        # deploy only master branch
        - deploy:
            command: |
              if [ "${CIRCLE_BRANCH}" == "master" ]; then
                chmod +x scripts/deploy.sh
                ./scripts/deploy.sh
              fi
  \end{lstlisting}
  \caption{Initial Build Config File}
\end{figure}

The \texttt{.circleci/config.yml} file above, describes the initial build steps of the Quiz Tool.
Code is checked out from the version control, all the dependencies necessary to perform following
steps are installed, the project is then built and started using docker-compose, before the
\texttt{curl localhost} command checks if the application is up and running. Finally, if
the current branch being built is \texttt{master}, the \texttt{deploy.sh} bash script runs, which
deploys the application to production.

\subsection{Production Environment}
The production environment of the tool is hosted on the AWS cloud. The AWS Elastic Beanstalk
has been chosen specificaly, as applications in
various programming languages can be deployed with ease, wihout having to worry about
the infrastructure running these applications\cite{37}. The Multicontainer Docker AWS Elastic
Beanstalk\cite{38} environment, creates a single Amazon EC2\cite{39}
instance and uses ECS (Amazon Container Service)\cite{40} to coordinate container deployments to
multicontainer Docker environments. The similarity with docker-compose, means the Quiz Tool
would behave similarly on developer's machine, in testing and in production.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.8\textwidth]{elasticbeanstalk.jpg}
    \caption{Quiz Tool Production Environment}
    \label{fig:ebs}
\end{figure}

\texttt{docker-compose.yml} files define how docker-compose should run Docker containers together.
\texttt{Dockerrun.aws.json} is the equivalent configuration file to specify relationships between Docker
containers running in the Multicontainer Elastic Beanstalk environment. The format of the config file below is very
similar to the docker-compose configuration files. The major
difference is that the AWS Elastic Beanstalk does not build Docker images itself, and images have
to be pulled dynamically from Docker registries. Docker registries are simply servers used for storage and
distribution of Docker images.

\begin{figure}[ht]
  \begin{lstlisting}[basicstyle=\tiny, breaklines=true]
  {
      "AWSEBDockerrunVersion": 2,
      "containerDefinitions": [
          {
              "name": "client",
              "image": "993389244112.dkr.ecr.eu-west-2.amazonaws.com/quiz-tool-client:latest",
              "memory": 128,
              "essential": true,
              "portMappings": [
                  {
                      "hostPort": 80,
                      "containerPort": 80
                  }
              ],
              "links": [
                  "server_node"
              ]
          },
          {
              "name": "server_node",
              "image": "993389244112.dkr.ecr.eu-west-2.amazonaws.com/quiz-tool-server:latest",
              "memory": 128,
              "essential": true,
              "links": [
                "database"
              ]
          },
          {
            "name": "database",
            "image": "mongo",
            "memory": 128,
            "essential": true,
            "portMappings": [
                {
                    "hostPort": 27017,
                    "containerPort": 27017
                }
            ]
          }
      ]
  }
  \end{lstlisting}
  \caption{Dockerrun.aws.json}
\end{figure}
\newpage

\subsubsection{Circle CI and AWS Integration}
- Circle CI <-> AWS Integration - deploy.sh file and Circle CI SSH setup
- graph showing how containers are pulled from the docker repositories before deployment

\subsection{Story Boards}

\subsection{Sprint Retrospective}

\section{Sprint 2 - Bare Bone Application}
\subsection{Sprint Planning}

\subsection{Sprint Retrospective}
\section{Sprint 3 - Add Quizes}
\subsection{Sprint Planning}

\subsection{Sprint Retrospective}
\section{Sprint 4 - Fancy Quizes and Defect Fixing}
\subsection{Sprint Planning}

\subsection{Sprint Retrospective}
\section{Sprint 5 - Persistence, Report Generation and Testing}
\subsection{Sprint Planning}

\subsection{Sprint Retrospective}

\chapter{Final Design}

This chapter follows on the discussion of the individual sprints and summarises
the final design of the tool.

\chapter{Testing}

\section{Server Side Unit Tests}
\section{Client Side Unit Tests}
\section{Selenium Integration Tests}

% You should concentrate on the more important aspects of the design. It is essential that an overview is presented before going into detail. As well as describing the design adopted it must also explain what other designs were considered and why they were rejected.%% The design should describe what you expected to do, and might also explain areas that you had to revise after some investigation.%% Typically, for an object-oriented design, the discussion will focus on the choice of objects and classes and the allocation of methods to classes. The use made of reusable components should be described and their source referenced. Particularly important decisions concerning data structures usually affect the architecture of a system and so should be described here.%% How much material you include on detailed design and implementation will depend very much on the nature of the project. It should not be padded out. Think about the significant aspects of your system. For example, describe the design of the user interface if it is a critical aspect of your system, or provide detail about methods and data structures that are not trivial. Do not spend time on long lists of trivial items and repetitive descriptions. If in doubt about what is appropriate, speak to your supervisor.%% You should also identify any support tools that you used. You should discuss your choice of implementation tools - programming language, compilers, database management system, program development environment, etc.%% Some example sub-sections may be as follows, but the specific sections are for you to define.

% \section{Overall Architecture}
%
% \section{Some detailed design}
%
% \subsection{Even more detail}
%
% \section{User Interface}
%
% \section{Other relevant sections}

% \chapter{Implementation}
% The implementation should look at any issues you encountered as you tried to implement your
% design. During the work, you might have found that elements of your design were unnecessary or
% overly complex; perhaps third party libraries were available that simplified some of the functions
% that you intended to implement. If things were easier in some areas, then how did you adapt your
% project to take account of your findings?
% It is more likely that things were more complex than you first thought. In particular, were there
% any problems or difficulties that you found during implementation that you had to address? Did
% such problems simply delay you or were they more significant?
% You can conclude this section by reviewing the end of the implementation stage against the
% planned requirements

% \chapter{Testing}
%
% Detailed descriptions of every test case are definitely not what is required here. What is important is to show that you adopted a sensible strategy that was, in principle, capable of testing the system adequately even if you did not have the time to test the system fully.
%
% Provide information in the body of your report and the appendix to explain the testing that has been performed. How does this testing address the requirements and design for the project?
%
% How comprehensive is the testing within the constraints of the project?  Are you testing the normal working behaviour? Are you testing the exceptional behaviour, e.g. error conditions? Are you testing security issues if they are relevant for your project?
%
% Have you tested your system on ``real users''? For example, if your system is supposed to solve a problem for a business, then it would be appropriate to present your approach to involve the users in the testing process and to record the results that you obtained. Depending on the level of detail, it is likely that you would put any detailed results in an appendix.
%
% The following sections indicate some areas you might include. Other sections may be more appropriate to your project.

% \section{Overall Approach to Testing}
%
% \section{Automated Testing}
%
% \subsection{Unit Tests}
%
% \subsection{User Interface Testing}
%
% \subsection{Stress Testing}
%
% \subsection{Other types of testing}
%
% \section{Integration Testing}
%
% \section{User Testing}
